<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>R-TYPE: Technical and Comparative Study</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">R-TYPE<span id="projectnumber">&#160;0.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Technical and Comparative Study </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md73"></a>
Table of Contents</h1>
<ul>
<li>Introduction</li>
<li>Programming Language<ul>
<li>C++</li>
<li>CMake</li>
</ul>
</li>
<li>Graphics Library<ul>
<li>SFML</li>
<li>ImGui</li>
</ul>
</li>
<li>Networking Techniques<ul>
<li>TCP</li>
<li>Architecture of the rooms and lobby</li>
<li>UDP</li>
<li>Using UDP for in game communication</li>
<li>Asio</li>
</ul>
</li>
<li>Data Structures<ul>
<li>Using ECS ​​Architecture</li>
<li>Client algorithm</li>
<li>Server Algorithm</li>
</ul>
</li>
<li>Storage<ul>
<li>JSON</li>
<li>Using the nlohmann/json library</li>
</ul>
</li>
<li>Data Security and Integrity</li>
</ul>
<h1><a class="anchor" id="autotoc_md74"></a>
Introduction</h1>
<p>This document provides a comparative study of the technologies employed in the project, focusing on programming languages, graphics libraries, algorithms, networking techniques, and more.</p>
<p>The goal is to justify the choice of each technology based on their relevance and effectiveness in addressing the project's requirements.</p>
<h1><a class="anchor" id="autotoc_md75"></a>
Programming Language</h1>
<h2><a class="anchor" id="autotoc_md76"></a>
C++</h2>
<p>For our project inspired by <b>R-Type</b>, we chose to use <b>C++</b> as the primary programming language.</p>
<p>This strategic choice is based on the performance, flexibility, and resource management requirements necessary to develop a quality video game.</p>
<h3><a class="anchor" id="autotoc_md77"></a>
Use Cases</h3>
<p>C++ has been used in several aspects of our project:</p>
<ul>
<li><b>Game Engine</b>: Development of the game engine to manage game loops, user inputs, and game logic.</li>
<li><b>Entity Management</b>: Implementation of the ECS (Entity-Component-System) architecture to manage entities and their behaviors in a modular and efficient manner.</li>
<li><b>Graphics and Rendering</b>: Integration of libraries like SFML for graphical rendering and resource management, allowing for real-time graphics display.</li>
</ul>
<h3><a class="anchor" id="autotoc_md78"></a>
Advantages</h3>
<ul>
<li><b>High Performance</b>: C++ is known for its speed and efficiency, providing optimal performance essential for video game development.</li>
<li><b>Memory Control</b>: Manual memory management allows for optimization of resource usage and ensures low latency.</li>
<li><b>Object-Oriented Programming</b>: C++ enables the use of object-oriented programming concepts, promoting code reuse and modularity.</li>
<li><b>Rich Ecosystem</b>: With a wide range of libraries and tools, C++ facilitates the integration of advanced features and enhances development.</li>
</ul>
<h3><a class="anchor" id="autotoc_md79"></a>
Disadvantages</h3>
<ul>
<li><b>Complexity</b>: C++ can be more complex to master than other languages, especially for novice developers, due to its syntax and advanced concepts (like memory management).</li>
<li><b>Development Time</b>: C++ projects may require more time for implementation and debugging due to this complexity.</li>
</ul>
<h3><a class="anchor" id="autotoc_md80"></a>
Conclusion</h3>
<p>Using <b>C++</b> for the development of our R-Type inspired game has allowed us to leverage its many features and advantages. This language offers the performance, flexibility, and control necessary to achieve an ambitious video game project. Despite some drawbacks related to its complexity, the benefits far outweigh the challenges, making C++ a wise choice for our development.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md82"></a>
CMake</h2>
<p>In our project inspired by <b>R-Type</b>, we chose <b>CMake</b> as the main tool for compiling and managing the configuration of our application.</p>
<p>This choice was motivated by the need to ensure efficient compilation and portability across different platforms.</p>
<h3><a class="anchor" id="autotoc_md83"></a>
Use Cases</h3>
<p>CMake has been used in several aspects of our project:</p>
<ul>
<li><b>Build Management</b>: CMake automates the compilation process of our C++ code and manages dependencies between files.</li>
<li><b>Cross-Platform Configuration</b>: CMake allows generating project files suitable for different development environments (Visual Studio, Makefiles, etc.), thus facilitating compilation on various platforms (Windows, macOS, Linux).</li>
<li><b>Library Integration</b>: CMake simplifies the integration and configuration of third-party libraries used in the project, such as SFML and ImGui.</li>
</ul>
<h3><a class="anchor" id="autotoc_md84"></a>
Advantages</h3>
<ul>
<li><b>Cross-Platform</b>: CMake enables the development of applications that can be compiled on multiple operating systems without major changes to the source code.</li>
<li><b>Ease of Use</b>: With a simple and intuitive scripting language, CMake makes project management easier, even for novice developers.</li>
<li><b>Dependency Management</b>: CMake simplifies the inclusion of external libraries and manages dependencies effectively, reducing the risk of errors during compilation.</li>
<li><b>Flexibility</b>: CMake offers great flexibility in configuring build options, allowing adaptation of the project to specific user needs.</li>
</ul>
<h3><a class="anchor" id="autotoc_md85"></a>
Disadvantages</h3>
<ul>
<li><b>Initial Complexity</b>: Although CMake is powerful, its initial configuration can be complex, especially for large projects with many dependencies.</li>
<li><b>Variable Documentation</b>: The quality of documentation can vary, making some features difficult to grasp for new users.</li>
<li><b>Dependency on CMake</b>: Developers must install CMake to compile the project, which can add an extra step in the configuration process.</li>
</ul>
<h3><a class="anchor" id="autotoc_md86"></a>
Conclusion</h3>
<p>Using <b>CMake</b> for the compilation and management of our R-Type inspired project has been a strategic decision aimed at ensuring optimal portability and flexibility. CMake has allowed us to automate the compilation process, manage dependencies effectively, and facilitate cross-platform development. The advantages of CMake make it a wise choice for our project, ensuring a smooth and efficient development experience.</p>
<h1><a class="anchor" id="autotoc_md87"></a>
Graphics Library</h1>
<h2><a class="anchor" id="autotoc_md88"></a>
SFML</h2>
<p>For the graphical development of our R-Type inspired game, we opted for <b>SFML</b> (Simple and Fast Multimedia Library). This choice was motivated by several advantages, including its ease of use, high performance, and wide range of features suited for game development.</p>
<h3><a class="anchor" id="autotoc_md89"></a>
Why SFML?</h3>
<p><b>SFML</b> is a multimedia library that facilitates the management of graphics, sound, user inputs, and much more. It is particularly well-suited for video games due to its simple and efficient architecture, allowing developers to create graphical applications in C++ without having to manage complex low-level details.</p>
<h3><a class="anchor" id="autotoc_md90"></a>
Use Cases in Our Project</h3>
<p>We used SFML for the following elements:</p>
<ul>
<li><b>Graphics Display</b>: SFML allowed us to easily load and display sprites, backgrounds, and other essential graphical elements for the game. Its 2D rendering system is optimized to provide smooth and responsive performance, which is crucial for a dynamic shoot'em up.</li>
<li><b>Event Management</b>: The SFML library offers a simple and efficient event management system, facilitating the detection of user inputs, such as player movements, shooting, and interactions with the interface.</li>
<li><b>Sound and Music</b>: SFML also allows for sound and music management, enriching the gaming experience by adding sound effects and an immersive soundtrack.</li>
</ul>
<h4><a class="anchor" id="autotoc_md91"></a>
Advantages of SFML</h4>
<ul>
<li><b>Ease of Use</b>: SFML has a user-friendly and intuitive interface, allowing developers to focus on creating their game rather than the complexity of low-level APIs.</li>
<li><b>Comprehensive Documentation</b>: The library is well-documented, with clear examples and guides, making learning and integration easier.</li>
<li><b>High Performance</b>: SFML is designed to be performant, utilizing advanced optimization techniques to ensure high refresh rates, even in graphically intense scenarios.</li>
<li><b>Cross-Platform Support</b>: SFML works on multiple platforms (Windows, Linux, macOS), allowing for the development of portable games without modifying the code.</li>
</ul>
<h3><a class="anchor" id="autotoc_md92"></a>
Limitations of SFML</h3>
<ul>
<li><b>Limited Features for 3D Games</b>: While SFML excels at developing 2D games, it offers fewer features for managing 3D graphics, which could be a constraint if we consider evolving towards three-dimensional games.</li>
<li><b>Lack of High-Level Features</b>: SFML focuses on providing low-level tools, meaning that some advanced features may require additional development or the integration of other libraries.</li>
</ul>
<h3><a class="anchor" id="autotoc_md93"></a>
Conclusion</h3>
<p>Using SFML for the graphical display of our prototype has proven to be a wise choice. Its simplicity, performance, and flexibility have allowed us to create an immersive and dynamic gaming experience while focusing on gameplay mechanics and creative design.</p>
<p>SFML perfectly meets our current needs, offering a robust and effective solution for the development of our game.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md95"></a>
ImGui</h2>
<p><img src="../../technicalAssets/imgui-representation.gif" alt="Alt text" class="inline"/></p>
<p>For the graphical interface development of our R-Type inspired game, we chose to use <b>ImGUI</b> (Immediate Mode GUI). This choice was motivated by several advantages, including rapid development, flexibility, and easy integration with graphics engines.</p>
<h3><a class="anchor" id="autotoc_md96"></a>
Why ImGUI?</h3>
<p><b>ImGUI</b> is a graphical user interface library that operates on the principle of Immediate Mode, allowing for the creation of dynamic and responsive user interfaces. It is lightweight, easy to integrate, and offers a great degree of customization, making it an excellent choice for video games and development tools.</p>
<h3><a class="anchor" id="autotoc_md97"></a>
Use Cases in Our Project</h3>
<p>We used ImGUI to create the following interface elements:</p>
<ul>
<li><b>Heads-Up Display (HUD)</b>: The HUD of the game, which displays essential information such as the score, remaining lives, and player status, was developed with ImGUI, providing a smooth and immersive user experience.</li>
<li><b>Lobby and Game Rooms</b>: ImGUI was used to create the lobby interface, allowing players to group together and select rooms before starting a game. This interface is intuitive and responsive, facilitating navigation and interaction among players.</li>
</ul>
<h3><a class="anchor" id="autotoc_md98"></a>
Advantages of ImGUI</h3>
<ul>
<li><b>Rapid Development</b>: ImGUI allows for the quick and efficient creation of user interfaces, reducing development time and enabling a focus on game features.</li>
<li><b>Ease of Integration</b>: ImGUI can be easily integrated into various graphics engines, making it versatile for different development projects.</li>
<li><b>Flexibility and Customization</b>: ImGUI offers a high degree of customization, allowing developers to design interfaces tailored to their specific needs without constraints.</li>
<li><b>Simplicity of Use</b>: The simple and intuitive syntax of ImGUI makes it easy to create interface elements, making the library accessible even for less experienced developers.</li>
</ul>
<h3><a class="anchor" id="autotoc_md99"></a>
Limitations of ImGUI</h3>
<ul>
<li><b>Not Optimized for Complex Interfaces</b>: While ImGUI is excellent for simple and dynamic interfaces, it can become less suitable for more complex user interfaces that require advanced state management and hierarchization.</li>
<li><b>Dependence on the Rendering Loop</b>: Since ImGUI operates in immediate mode, each interface element must be redrawn every frame, which can pose performance issues in heavily loaded scenarios.</li>
</ul>
<h3><a class="anchor" id="autotoc_md100"></a>
Conclusion</h3>
<p>Using the ImGUI library for the graphical interface of our prototype has proven to be a strategic and effective choice. Its rapid development, flexibility, and ease of integration have allowed us to create an engaging and responsive user interface while maintaining a high level of performance.</p>
<p>ImGUI perfectly meets our current needs, offering a dynamic and intuitive solution that enriches the user experience and simplifies the development process.</p>
<h2><a class="anchor" id="autotoc_md101"></a>
Networking Techniques</h2>
<h2><a class="anchor" id="autotoc_md102"></a>
TCP</h2>
<p>TCP (Transmission Control Protocol) is a communication protocol used on the Internet and in many private networks. It is part of the TCP/IP protocol suite and operates above the IP (Internet Protocol) layer. Its main role is to ensure reliable data transmission between two machines connected to the network.</p>
<h3><a class="anchor" id="autotoc_md103"></a>
How TCP Works</h3>
<p>The TCP protocol relies on several mechanisms to ensure reliable and ordered communication between a client and a server:</p>
<ul>
<li><b>Connection Establishment</b>: Before data can be exchanged, TCP establishes a connection between the two parties through a three-step process called the handshake.</li>
<li><b>Reliable Transmission</b>: TCP guarantees that all data sent by the client arrives in order and without errors at the server.</li>
<li><b>Flow Control</b>: TCP dynamically adjusts the amount of data sent based on the recipient's capacity to receive it, to avoid overwhelming the recipient.</li>
<li><b>Connection Termination</b>: Once the transmission is complete, TCP closes the connection cleanly through a defined process.</li>
</ul>
<h3><a class="anchor" id="autotoc_md104"></a>
Advantages of TCP</h3>
<ul>
<li><b>Reliability</b>: TCP ensures that all transmitted data arrives at its destination without errors, in the correct order, and without duplication.</li>
<li><b>Flow and Congestion Control</b>: TCP dynamically adjusts the amount of data sent to adapt to network conditions.</li>
<li><b>Ordered Transmission</b>: Data segments are reassembled in the correct order by the receiver, even if the packets arrive out of order.</li>
<li><b>Automatic Error Recovery</b>: If data segments are lost or corrupted during transmission, TCP ensures that they are retransmitted.</li>
</ul>
<h2><a class="anchor" id="autotoc_md105"></a>
Architecture of the Rooms and Lobby</h2>
<p>The diagram below illustrates the player management structure in the game server, comprising several rooms and a lobby. This architecture has been designed to efficiently handle player connections and interactions within the game. Here is a detailed explanation of the key components and how they function:</p>
<p><img src="../../technicalAssets/room.png" alt="Alt text" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md106"></a>
1. Lobby</h3>
<p>The lobby is the welcome area where players can gather before joining a game room. It allows players to connect, chat, and choose the room they want to enter. Players can also see who is online (e.g., P4, P5) and select their room.</p>
<h3><a class="anchor" id="autotoc_md107"></a>
2. Rooms</h3>
<p>Each room is a dedicated space for gameplay. The rooms (Room 1, Room 2, Room 3, Room 4, etc.) allow players to compete in matches. Each room can accommodate multiple players (P1, P2, P3, etc.) and has its own game logic. Rooms are configurable for specific games, allowing flexibility in the type of game offered.</p>
<h3><a class="anchor" id="autotoc_md108"></a>
3. Game Management</h3>
<p>Next to the rooms, the server can create games (Game 2, Game 3, etc.) where players are assigned to specific teams. This allows for multiple games to be managed simultaneously, isolating players in different rooms.</p>
<h3><a class="anchor" id="autotoc_md109"></a>
4. Communication via TCP</h3>
<p>This architecture has been implemented using the TCP (Transmission Control Protocol) for the following reasons:</p>
<ul>
<li><b>Reliability</b>: TCP guarantees the delivery of data packets in the correct order. This is essential in a gaming environment where every action and movement of players must be correctly synchronized and received.</li>
<li><b>Flow and Congestion Control</b>: TCP automatically adjusts the data transmission rate between the server and clients, which is crucial for maintaining a smooth gaming experience, even if the network is congested.</li>
<li><b>Persistent Connection</b>: With TCP, a connection is established between the client and server until one side decides to close it. This facilitates continuous interactions, such as real-time updates of player states in the lobby and rooms.</li>
</ul>
<h3><a class="anchor" id="autotoc_md110"></a>
Conclusion</h3>
<p>The architecture of the rooms and the lobby, implemented with TCP, provides a robust and effective solution for managing player interactions in the game. It ensures smooth and reliable communication, which is essential for an immersive and dynamic gaming experience.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md112"></a>
UDP</h2>
<p>UDP (User Datagram Protocol) is a communication protocol used on the Internet for the fast sending of messages or <b>datagrams</b> without guarantees of delivery or order. Unlike TCP, UDP is a <b>connectionless</b> transport protocol, meaning it does not establish a connection before sending data.</p>
<p>It is part of the <b>TCP/IP</b> protocol suite, like TCP, but UDP stands out for its simplicity and efficiency in certain situations, particularly where speed and low latency are prioritized over reliability.</p>
<h3><a class="anchor" id="autotoc_md113"></a>
&lt;strong&gt;Principle of Operation of UDP&lt;/strong&gt;</h3>
<p>UDP is designed to be fast and lightweight. It lacks the complex connection management and reliable transmission mechanisms of TCP, which helps reduce delays and network overhead:</p>
<ul>
<li><b>Direct Packet Sending</b>: Unlike TCP, UDP does not perform a connection step. Data (datagrams) are simply sent from one point to another without confirmation of receipt.</li>
<li><b>Absence of Reliability Mechanism</b>: UDP does not guarantee that data reaches its destination, and packets may be lost, duplicated, or arrive out of order without any correction.</li>
<li><b>Unordered Transmission</b>: Since there is no segmentation numbering like in TCP, UDP does not guarantee that datagrams arrive in the order they were sent.</li>
<li><b>No Flow or Congestion Control</b>: Unlike TCP, UDP does not regulate data flow or account for network congestion, making it faster but riskier in case of network overload.</li>
</ul>
<h3><a class="anchor" id="autotoc_md114"></a>
&lt;strong&gt;Advantages of UDP&lt;/strong&gt;</h3>
<ul>
<li><b>Speed</b>: Since there is no prior connection step or reliable transmission management mechanism, UDP is much faster than TCP. It is ideal for applications where latency must be minimized, such as online gaming, VoIP calls, or live streaming.</li>
<li><b>Low Overhead</b>: UDP generates very little header overhead, as it does not need to manage mechanisms like acknowledgments or segment numbering. This allows for a high data throughput.</li>
<li><b>Non-blocking Transmission</b>: UDP does not wait for confirmation from the recipient to continue sending data, making it non-blocking and avoiding retransmission delays that can slow down exchanges.</li>
</ul>
<h2><a class="anchor" id="autotoc_md115"></a>
Using UDP for in game communication</h2>
<p>In the context of our game, we chose to use UDP for communication between the client and the server due to the characteristics mentioned above, which perfectly match the needs of a dynamic and responsive application. Here’s how this is reflected in our architecture:</p>
<ul>
<li><b>Real-Time Event Transmission</b>: UDP allows for the rapid sending of datagrams containing critical information about player actions, such as movements, attacks, or state changes. This approach ensures that players receive game state updates almost instantly, which is essential for maintaining immersion and responsiveness in a gaming environment.</li>
<li><b>Latency Management</b>: By using UDP, we minimize communication delays. Each action from a player is immediately transmitted to the server without waiting for confirmations. This is particularly important during real-time competitions, where every millisecond counts.</li>
<li><b>Bandwidth Efficiency</b>: Due to the low overhead of UDP, we can send more information with less data. This frees up bandwidth for other operations while maintaining a high throughput for game-related information.</li>
<li><b>Game Data Updates</b>: Information regarding player states, scores, and environmental changes is sent via UDP. While we accept that some packets may be lost or arrive out of order, the gaming experience remains fluid. Essential data, such as player positions, is regularly updated to ensure that the game stays synchronized, even if some packets are occasionally missing.</li>
<li><b>Tolerance for Packet Loss</b>: The game is designed to be tolerant of packet loss, which is an inherent characteristic of UDP. The game mechanics are robust enough to handle missing information without harming the overall player experience.</li>
</ul>
<h3><a class="anchor" id="autotoc_md116"></a>
&lt;strong&gt;Conclusion&lt;/strong&gt;</h3>
<p>Using UDP for communication between the client and server of our game allows us to achieve optimal performance. By quickly sending critical information and reducing latency, we have created a smooth and dynamic gaming experience that meets the demands of real-time games. This approach enables us to leverage the advantages of UDP while intelligently managing the risks associated with its unreliable nature.</p>
<h2><a class="anchor" id="autotoc_md117"></a>
Asio</h2>
<p><img src="../../technicalAssets/asio.gif" alt="Alt text" class="inline"/></p>
<p>For network communication in our <b>R-Type</b> inspired project, we chose to use <b>Asio</b>, a C++ library that allowed us to implement <b>TCP</b> and <b>UDP</b> protocols efficiently.</p>
<p>Asio was essential in establishing smooth communication between the client and server.</p>
<h3><a class="anchor" id="autotoc_md118"></a>
Use Cases</h3>
<p>Asio was utilized in several aspects of our project:</p>
<ul>
<li><b>Client-Server Communication</b>: With Asio, we were able to establish TCP and UDP connections between the client and the server, enabling real-time data exchange.</li>
<li><b>Event Management</b>: Asio facilitates asynchronous I/O management, allowing us to handle network connections efficiently without blocking the rest of the program.</li>
<li><b>Data Transmission</b>: Asio manages data transfer, ensuring that messages are sent and received correctly, whether via TCP or UDP.</li>
</ul>
<h3><a class="anchor" id="autotoc_md119"></a>
Advantages</h3>
<ul>
<li><b>Performance</b>: Asio is designed to be performant and lightweight, which is crucial for a real-time game where latency must be minimized.</li>
<li><b>Support for Multiple Protocols</b>: Asio allows for easy handling of multiple network protocols (TCP and UDP), providing the flexibility needed to adapt our network architecture to the game’s requirements.</li>
<li><b>Asynchronous by Nature</b>: The asynchronous management of connections frees up resources and enhances the responsiveness of the application, which is essential for a dynamic gaming environment.</li>
<li><b>Documentation and Community</b>: Asio benefits from good documentation and an active community, making it easier to troubleshoot issues and learn its features.</li>
</ul>
<h3><a class="anchor" id="autotoc_md120"></a>
Disadvantages</h3>
<ul>
<li><b>Error Management Complexity</b>: Error handling in an asynchronous environment can be more complex, requiring special attention to ensure that exceptions are properly managed.</li>
<li><b>Initial Setup</b>: Setting up Asio and integrating it into the project may require additional effort compared to simpler solutions.</li>
</ul>
<h3><a class="anchor" id="autotoc_md121"></a>
Conclusion</h3>
<p>The use of <b>Asio</b> to manage our <b>TCP</b> and <b>UDP</b> protocols was a crucial strategic choice in the development of our R-Type inspired project. <br  />
 Asio enabled us to establish effective communication between the client and server while ensuring asynchronous management of connections. <br  />
 The advantages of Asio in terms of performance, flexibility, and protocol support make it an ideal solution for our game's needs.</p>
<h1><a class="anchor" id="autotoc_md122"></a>
Data Structures</h1>
<h2><a class="anchor" id="autotoc_md123"></a>
Using ECS ​​Architecture</h2>
<p>In the development of our <b>R-Type</b> inspired project, we adopted the <b>Entity-Component-System (ECS)</b> architecture. This approach allowed us to create a robust and flexible game engine, facilitating the development and extension of game features.</p>
<p><img src="../../technicalAssets/data-structure.png" alt="Alt text" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md124"></a>
Use Cases</h3>
<p>The ECS architecture was implemented in several key aspects of our project:</p>
<ul>
<li><b>Entity Management</b>: Each game object (players, enemies, items) is represented as an entity, allowing for a clear separation of different entities within the game world.</li>
<li><b>Modular Components</b>: The characteristics of entities are defined by components, enabling us to easily add or modify functionalities without affecting other parts of the code.</li>
<li><b>Processing Systems</b>: Systems are responsible for the game logic, processing entities based on their components, which allows for efficient updating and rendering of game elements.</li>
</ul>
<h3><a class="anchor" id="autotoc_md125"></a>
Advantages</h3>
<ul>
<li><b>Flexibility</b>: The ECS architecture allows for the addition of new entities and behaviors without requiring significant changes to the existing code, which is essential for rapid iteration during development.</li>
<li><b>Reusability</b>: Components can be reused across different entities, reducing redundancy and simplifying resource management.</li>
<li><b>Performance</b>: By separating data and logic, the ECS architecture can improve performance by allowing specific optimizations, such as parallel processing of systems.</li>
<li><b>Code Clarity</b>: The clear structure of ECS helps organize the code, making development and maintenance simpler and more understandable.</li>
</ul>
<h3><a class="anchor" id="autotoc_md126"></a>
Disadvantages</h3>
<ul>
<li><b>Initial Complexity</b>: Setting up an ECS architecture can be complex, particularly for developers who are not familiar with this model.</li>
<li><b>Management Overhead</b>: Managing entities, components, and systems can introduce overhead, especially in smaller projects where a simpler approach might suffice.</li>
</ul>
<h3><a class="anchor" id="autotoc_md127"></a>
Conclusion</h3>
<p>The adoption of the <b>ECS</b> architecture in our project was crucial in creating an efficient and modular game engine. <br  />
 This approach allowed us to easily manage the increasing complexity of the game while maintaining the flexibility needed for expansion and iteration. <br  />
 The advantages in terms of performance, reusability, and code clarity make ECS an ideal solution for our game development.</p>
<h2><a class="anchor" id="autotoc_md128"></a>
Client algorithm</h2>
<p>The client algorithm is essential for managing player interactions with the game. It ensures the creation and management of game entities while maintaining communication with the server. Here is a detailed explanation of each step of the algorithm:</p>
<p><img src="../../technicalAssets/flow-chart-client.png" alt="Alt text" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md129"></a>
1. Startup</h3>
<ul>
<li><b>Start</b> The process begins here, initiating the subsequent steps.</li>
</ul>
<h3><a class="anchor" id="autotoc_md130"></a>
2. Entity Creation</h3>
<ul>
<li><b>Create Static Entity</b> In this step, static entities, such as walls or obstacles, are created. This helps define the basic structure of the game level.</li>
<li><b>Create Player</b> A player is created, initializing their attributes and placing them within the game environment.</li>
<li><b>Notify Server</b> A notification is sent to the server to indicate that a new player has been created. This allows the server to maintain synchronization with the game's state.</li>
</ul>
<h3><a class="anchor" id="autotoc_md131"></a>
3. Player Input Management</h3>
<ul>
<li><b>Wait for Player Input</b> The client waits for player actions. This may include movements, attacks, or other interactions with the environment.</li>
</ul>
<h3><a class="anchor" id="autotoc_md132"></a>
4. Server Communication</h3>
<ul>
<li><b>Get Server Data</b> At this stage, the client retrieves data from the server. This may include updates on the positions of other players, the states of entities, or other relevant information.</li>
<li><b>Create / Modify / Delete Entity</b> Based on the data received from the server or the player's actions, the client can create, modify, or delete entities in the game. This ensures that the game's state remains consistent and up-to-date.</li>
<li><b>Notify Server</b> A new notification is sent to the server to report the changes made by the player.</li>
</ul>
<h3><a class="anchor" id="autotoc_md133"></a>
5. Game Rendering</h3>
<ul>
<li><b>Render Game</b> Finally, the game is rendered on the screen. This involves drawing all entities and visual effects based on the current state of the game.</li>
</ul>
<h3><a class="anchor" id="autotoc_md134"></a>
Conclusion</h3>
<p>This client algorithm is designed to provide a smooth and responsive gaming experience. <br  />
 It effectively manages entity creation, server communication, and game rendering, ensuring that players can interact intuitively and immersively.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md136"></a>
Server Algorithm</h2>
<p>The server algorithm is essential for managing the game state, client interactions, and gameplay simulation. It also ensures data synchronization between different players. Here is a detailed explanation of each step of the algorithm:</p>
<p><img src="../../technicalAssets/flow-chart-server.png" alt="Alt text" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md137"></a>
1. Startup</h3>
<ul>
<li><b>Start</b> The process begins here, initiating the subsequent steps.</li>
</ul>
<h3><a class="anchor" id="autotoc_md138"></a>
2. Entity Creation</h3>
<ul>
<li><b>Create Static Entity</b> In this step, static entities, such as walls or obstacles, are created. This helps define the game environment.</li>
</ul>
<h3><a class="anchor" id="autotoc_md139"></a>
3. Game Simulation</h3>
<ul>
<li><b>Simulate Game</b> The server simulates the game by updating the positions of entities, calculating interactions, and managing game logic in real-time.</li>
</ul>
<h3><a class="anchor" id="autotoc_md140"></a>
4. Communication with the Client</h3>
<ul>
<li><b>Get Client Data</b> At this stage, the server receives data from the clients. This may include player actions, state updates, or other relevant information.</li>
<li><b>Create / Modify / Delete Entity</b> Based on the data received from the clients, the server can create, modify, or delete entities. <br  />
 This ensures that the game state remains consistent and up-to-date.</li>
<li><b>Notify Client</b> After making the necessary updates, the server notifies the clients of the changes, allowing them to adjust their game state accordingly.</li>
</ul>
<h3><a class="anchor" id="autotoc_md141"></a>
Conclusion</h3>
<p>This server algorithm is designed to provide effective management of game interactions and maintain synchronization among clients. It handles entity creation, game simulation, and communication with clients, ensuring a smooth and coherent gaming experience for all players.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md143"></a>
Storage</h2>
<p>For data storage in our R-Type inspired game, we opted for the use of <b>JSON configuration files</b>. This choice was motivated by several practical advantages, including simplicity, readability, and compatibility.</p>
<h3><a class="anchor" id="autotoc_md144"></a>
Why JSON?</h3>
<p>The <b>JSON</b> (JavaScript Object Notation) format is lightweight, easy to read, and widely supported in almost all development environments. It allows for structured data to be stored in a textual format, making it ideal for video game configuration, especially in a prototype where flexibility and simplicity are desired.</p>
<h3><a class="anchor" id="autotoc_md145"></a>
Use Cases in Our Project</h3>
<p>We used JSON files to manage the following configurations:</p>
<ul>
<li><b>Level Parameters</b> Each game level is described in a JSON file, specifying information such as the number of enemies, types of obstacles, and boss spawn parameters.</li>
<li><b>Player Profiles</b> Information such as score, life, or player status is recorded in JSON files, allowing for flexible and simple management of this data.</li>
<li><b>Game Configurations</b> Global game parameters (like controls, difficulty, or graphical options) are also stored as a JSON file, allowing players to easily customize them.</li>
</ul>
<h3><a class="anchor" id="autotoc_md146"></a>
Advantages of JSON Format</h3>
<ul>
<li><b>Ease of Use</b> JSON is easy to manipulate for both reading and writing, with native support in many languages (such as <b>C++</b>, via third-party libraries).</li>
<li><b>Human Readability</b> JSON files are clear and can be directly edited by developers or game designers without needing specialized tools.</li>
<li><b>Flexibility</b> JSON allows for the representation of complex structures (nested objects, arrays) while remaining lightweight and easy to manage.</li>
<li><b>Portability</b> The JSON format is platform-independent, facilitating compatibility with other systems, servers, or configuration tools.</li>
</ul>
<h3><a class="anchor" id="autotoc_md147"></a>
Limitations of JSON Format</h3>
<ul>
<li><b>Not Optimized for Large Volumes of Data</b> If the game were to evolve into more complex systems with large amounts of data to manage (e.g., millions of players or gigantic maps), the JSON format would become inefficient in terms of performance.</li>
<li><b>Lack of Transaction Mechanisms</b> Unlike a relational database, JSON does not have mechanisms for handling transactions or ensuring data consistency in case of failures or interruptions when writing files.</li>
</ul>
<h3><a class="anchor" id="autotoc_md148"></a>
Conclusion</h3>
<p>Using JSON configuration files is a smart choice for this prototype project, combining simplicity and flexibility in data management. This approach allows us to focus on creative development and optimizing game mechanics while ensuring a clear and easily modifiable structure.</p>
<p>The JSON format perfectly meets our needs, offering an efficient and practical solution that promotes innovation and rapid implementation.</p>
<h2><a class="anchor" id="autotoc_md149"></a>
Using the nlohmann/json Library</h2>
<p>As part of our R-Type inspired project, we chose to use the <b>nlohmann/json</b> library for managing JSON files. This library allowed us to simplify data processing and improve development efficiency.</p>
<h3><a class="anchor" id="autotoc_md150"></a>
Use Cases</h3>
<p>The <b>nlohmann/json</b> library was integrated into our project for several tasks:</p>
<ul>
<li><b>Loading JSON Files</b> We used nlohmann/json to read configuration files and extract the necessary data for game configuration.</li>
<li><b>Data Manipulation</b> This library enabled us to create, modify, and query JSON objects intuitively, facilitating the management of game parameters.</li>
<li><b>Data Saving</b> nlohmann/json was also used to write modified data to JSON files, ensuring that all configurations and player profiles were correctly stored.</li>
</ul>
<h3><a class="anchor" id="autotoc_md151"></a>
Advantages</h3>
<ul>
<li><b>Ease of Use</b> The intuitive syntax of nlohmann/json makes manipulating JSON data simple and accessible, even for developers who are not experts in data management.</li>
<li><b>Performance</b> The library is designed to be fast and efficient, allowing operations on JSON data without affecting game performance.</li>
<li><b>Flexibility</b> nlohmann/json supports complex data structures, such as arrays and nested objects, enabling us to manage varied and scalable configurations.</li>
<li><b>Easy Integration</b> The library easily integrates into C++ projects, allowing us to use it without major constraints.</li>
</ul>
<h3><a class="anchor" id="autotoc_md152"></a>
Disadvantages</h3>
<ul>
<li><b>External Dependency</b> Using nlohmann/json adds a dependency to our project, which may pose issues if the library is no longer maintained or if major updates affect compatibility.</li>
<li><b>Memory Consumption</b> For very large JSON files, memory consumption can be a factor to consider, especially if the project evolves towards more complex data management.</li>
</ul>
<h3><a class="anchor" id="autotoc_md153"></a>
Conclusion</h3>
<p>Using the <b>nlohmann/json</b> library was a wise choice for managing JSON files in our project. It not only simplified data processing but also improved our development efficiency. The advantages in terms of ease of use, flexibility, and performance make this library a valuable asset in our approach to creating a game prototype.</p>
<h1><a class="anchor" id="autotoc_md154"></a>
Data Security and Integrity</h1>
<p>In the context of our <b>R-Type</b> inspired project, managing data security and integrity has been a priority. We have implemented various measures to protect player data and ensure a secure gaming environment.</p>
<h3><a class="anchor" id="autotoc_md155"></a>
Use Cases</h3>
<p>Security measures have been applied in several areas:</p>
<ul>
<li><b>Data Transmission</b> Communication between the client and server is protected by secure protocols to prevent interception and man-in-the-middle attacks.</li>
<li><b>Storage of Sensitive Data</b> Personal information and player scores are carefully managed to avoid unauthorized disclosure.</li>
</ul>
<h3><a class="anchor" id="autotoc_md156"></a>
Advantages</h3>
<ul>
<li><b>Data Protection</b> By applying robust security protocols, we protect player data from unauthorized access.</li>
<li><b>User Trust</b> By ensuring adequate security, we strengthen user trust in our product, which can lead to a more loyal user base.</li>
<li><b>Compliance</b> By adhering to security best practices, we comply with data protection regulations, which is essential for a modern product.</li>
</ul>
<h3><a class="anchor" id="autotoc_md157"></a>
Disadvantages</h3>
<ul>
<li><b>Complexity</b> Implementing security measures can add complexity to the development and maintenance of the code, requiring additional expertise.</li>
<li><b>Performance</b> Certain security measures, such as encryption, can incur performance costs, particularly in terms of latency during data transmission.</li>
</ul>
<h3><a class="anchor" id="autotoc_md158"></a>
Implemented Security Measures</h3>
<ul>
<li><b>Security Monitoring</b> We have integrated monitoring tools to detect any suspicious activity on the server and respond quickly in the event of a security breach.</li>
<li><b>Regular Updates</b> We plan regular updates to our code and dependencies to fix vulnerabilities and improve the overall security of the system.</li>
</ul>
<h3><a class="anchor" id="autotoc_md159"></a>
Conclusion</h3>
<p>Data security and integrity are essential in our project. By implementing appropriate security measures and remaining vigilant against potential threats, we ensure a safe and reliable gaming environment for our users. These efforts not only help protect player data but also enhance the reputation of our game in an increasingly competitive market. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
